

    def check_data(self, export_path: str) -> "CSV":
        """
        Notes:
            If other older files are stored in the master output folder this function will compare the cached
            dataframe with the older data in that folder. If new columns, or cells are identified, they will be
            added to the cached dataframe.

        Input:
            export_path: string --> Path To Folder Where Data Will Be Exported

        Output:
            None --> Cached Dataframe is modified

        GENERAL CAUTION: IF PRESENT OLDER MASTER FILES WILL BE DELETED
        """

        # Look For Older Files In Export Folder
        directory_ = os.listdir(export_path)
        for file_ in directory_:
            split_name = file_.split("_")
            if file_.__contains__("COMMENTS"):
                print("_".join(split_name))


        # FIX THIS PLEASE!!!!!!!


    def export_data(self, export_path: str) -> "CSV":
        """
        Notes:
            Given an export path, filter cached data by district name & create appropriate CSVs. If none are already
            there create new ones. If past versions are present combine & keep any new data provided by users.
            Caution, rows must be compared to master file already in file.
        Input:
            export_path: string --> Path To Folder Where Data Will Be Exported

        Output:
            CSVs --> A CSV For Each District
        """

        # Logic Check First | Export Data Based On District Type
        if str(type(QC_Checker.rd)) != "<class 'NoneType'>":
            for district in QC_Checker.rd["District"].unique():

                # Filter Data
                temp_df = QC_Checker.rd[QC_Checker.rd["District"] == district]
                full_ex_path = export_path + "\\" + QC_Checker.current_date + "_QC_MasterFile_" + district.strip() + ".xlsx"

                # Drop Unneeded Columns
                col_to_keep = ["File Number", "Address", "InDate", "Folder Name"]
                for col in temp_df.columns:
                    if col not in col_to_keep:
                        temp_df.drop(col, axis=1, inplace=True)

                # Add Additional Columns
                col_to_add = ["QC_Status", "Comments", "Actions", "StaffName", "CheckedByValen"]
                for new_col in col_to_add:
                    temp_df[new_col] = ""

                # Format Data
                self.__formatexcel(full_ex_path, temp_df)

            return
        print("Sequence Error Detected: First Load Data Into QC_Checker")





        #   PRIVATE METHODS
        def __formatexcel(self, full_ex_path, temp_df) -> bool:
            """
            Add basic excel formatting for easier end user experience
            """

            # Write Data To Excel | Add Formatting!!!
            with pd.ExcelWriter(full_ex_path, engine='xlsxwriter') as writer:

                # Write Dataframe To Excel, Initial Formatting
                df_len = len(temp_df)
                temp_df.to_excel(writer, sheet_name="Formatted_Applications", index=False)

                # Grab Workbook & Sheet
                workbook  = writer.book
                worksheet = writer.sheets["Formatted_Applications"]

                # Add a header format & alternating format
                header_format = workbook.add_format({'italic': True, 'bold': True, 'bg_color': '#CCCCCC' })
                alt1 = workbook.add_format({'bg_color': '#EEEEEE'})
                alt2 = workbook.add_format({'bg_color': '#DDDDDD'})
                workspace_fmt = workbook.add_format({'border': True})

                # Write the column headers with the defined format
                header_range = "A1:I1"
                worksheet.conditional_format(header_range, {'type': 'cell', 'criteria': '>', 'value': -99999999999, 'format': header_format})

                # Format Alternating Rows
                formats = cycle([alt1, alt2])
                for row in range(2, df_len + 2):
                    data_format = next(formats)

                    # Focus Row Range
                    x_row_range = f"A{row}:I{row}"
                    worksheet.conditional_format(x_row_range, {'type': 'cell', 'criteria': '>', 'value': -99999999999, 'format': data_format})

                # Final WorkSheet Fomatting
                worksheet.freeze_panes(1, 0)
                total_range = f"A1:I{df_len + 1}"
                worksheet.conditional_format(total_range, {'type': 'cell', 'criteria': '>', 'value': -99999999999, 'format': workspace_fmt})

                # Add Data Validation | Column E QC Status
                row_range = f"E2:E{df_len + 1}"
                worksheet.data_validation(row_range, {'validate': 'list', 'source': ["Not Checked", "In Progress", "Checked"]})

                # Add Data Validation | Column G Actions Taken
                row_range = f"G2:G{df_len + 1}"
                worksheet.data_validation(row_range, {'validate': 'list', 'source': ["Completed edits - ready to go", "Working on edits", "Edits not started"]})


                # Add Data Validation | Column H Design Tech Name
                row_range = f"I2:I{df_len + 1}"
                worksheet.data_validation(row_range, {'validate': 'list', 'source': ["Not Checked", "In Progress", "Checked"]})

                del temp_df, writer
